/* Autogenerated from insts.td. DO NOT EDIT */
#include "psx.h"

#define REG(gpr) state[gpr]
#define HI() state[33]
#define LO() state[34]
#define TGPR(name, gpr) uint32_t name = REG(gpr)

#define DEP(gpr) do { if(gpr != 0) cpu->ReadAbsorb[gpr] = 0; } while(0)
#define RES(gpr) do { if(gpr != 0) cpu->ReadAbsorb[gpr] = 0; } while(0)

#define DO_LDS() do { \
	state[cpu->LDWhich] = cpu->LDValue; \
	cpu->ReadAbsorb[cpu->LDWhich] = cpu->LDAbsorb; \
	cpu->ReadFudge = cpu->LDWhich; \
	cpu->ReadAbsorbWhich |= (cpu->LDWhich != 35) ? (cpu->LDWhich & 0x1F) : 0; \
	cpu->LDWhich = 35; \
} while(0)

#define DEFER_SET(gpr, val) do { cpu->LDWhich = gpr; cpu->LDValue = val; } while(0)

#define branch_default() do { } while(0)

#define INSNLOG(mnem) printf(#mnem " [%08x]\n", pc);

bool interpret(uint32_t *state, uint32_t pc, uint32_t inst) {
	switch((inst) >> (0x1a)) {
		case 0x0: {
			switch((inst) & (0x3f)) {
				case 0x0: {
					/* SLL */
					uint32_t rt = ((inst) >> (0x10)) & (0x1f);
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					uint32_t shamt = ((inst) >> (0x6)) & (0x1f);
					DEP(rt);
					RES(rd);
					TGPR(temp_1, rt);
					DO_LDS();
					if((rd) != (0x0)) { REG(rd) = (temp_1) << (shamt); }
					return(true);
					break;
				}
				case 0x2: {
					/* SRL */
					uint32_t rt = ((inst) >> (0x10)) & (0x1f);
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					uint32_t shamt = ((inst) >> (0x6)) & (0x1f);
					DEP(rt);
					RES(rd);
					TGPR(temp_2, rt);
					DO_LDS();
					if((rd) != (0x0)) { REG(rd) = (temp_2) >> (shamt); }
					return(true);
					break;
				}
				case 0x3: {
					/* SRA */
					uint32_t rt = ((inst) >> (0x10)) & (0x1f);
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					uint32_t shamt = ((inst) >> (0x6)) & (0x1f);
					DEP(rt);
					RES(rd);
					TGPR(temp_3, rt);
					DO_LDS();
					if((rd) != (0x0)) { REG(rd) = ((int32_t) (temp_3)) >> ((int32_t) (shamt)); }
					return(true);
					break;
				}
				case 0x4: {
					/* SLLV */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t rt = ((inst) >> (0x10)) & (0x1f);
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					DEP(rs);
					DEP(rt);
					RES(rd);
					TGPR(temp_4, rs);
					TGPR(temp_5, rt);
					DO_LDS();
					if((rd) != (0x0)) { REG(rd) = (temp_5) << (temp_4); }
					return(true);
					break;
				}
				case 0x6: {
					/* SRLV */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t rt = ((inst) >> (0x10)) & (0x1f);
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					DEP(rs);
					DEP(rt);
					RES(rd);
					TGPR(temp_6, rs);
					TGPR(temp_7, rt);
					DO_LDS();
					if((rd) != (0x0)) { REG(rd) = (temp_7) >> (temp_6); }
					return(true);
					break;
				}
				case 0x7: {
					/* SRAV */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t rt = ((inst) >> (0x10)) & (0x1f);
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					DEP(rs);
					DEP(rt);
					RES(rd);
					TGPR(temp_8, rs);
					TGPR(temp_9, rt);
					DO_LDS();
					if((rd) != (0x0)) { REG(rd) = ((int32_t) (temp_9)) >> ((int32_t) (temp_8)); }
					return(true);
					break;
				}
				case 0x8: {
					/* JR */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					DEP(rs);
					TGPR(temp_10, rs);
					DO_LDS();
					alignment(temp_10, 0x20, 0x0, pc);
					branch_to = temp_10;
					return(true);
					break;
				}
				case 0x9: {
					/* JALR */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					DEP(rs);
					RES(rd);
					TGPR(temp_11, rs);
					DO_LDS();
					if((rd) != (0x0)) { REG(rd) = ((pc) + (0x4)) + (0x4); }
					alignment(temp_11, 0x20, 0x0, pc);
					branch_to = temp_11;
					return(true);
					break;
				}
				case 0xc: {
					/* SYSCALL */
					uint32_t code = ((inst) >> (0x6)) & (0xfffff);
					DO_LDS();
					ps_syscall(code, pc, inst);
					return(true);
					break;
				}
				case 0xd: {
					/* BREAK */
					uint32_t code = ((inst) >> (0x6)) & (0xfffff);
					DO_LDS();
					break_(code, pc, inst);
					return(true);
					break;
				}
				case 0x10: {
					/* MFHI */
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					RES(rd);
					DO_LDS();
					if((rd) != (0x0)) { REG(rd) = HI(); }
					absorb_muldiv_delay();
					return(true);
					break;
				}
				case 0x11: {
					/* MTHI */
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					DEP(rd);
					TGPR(temp_12, rd);
					DO_LDS();
					HI() = temp_12;
					return(true);
					break;
				}
				case 0x12: {
					/* MFLO */
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					RES(rd);
					DO_LDS();
					if((rd) != (0x0)) { REG(rd) = LO(); }
					absorb_muldiv_delay();
					return(true);
					break;
				}
				case 0x13: {
					/* MTLO */
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					DEP(rd);
					TGPR(temp_13, rd);
					DO_LDS();
					LO() = temp_13;
					return(true);
					break;
				}
				case 0x18: {
					/* MULT */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t rt = ((inst) >> (0x10)) & (0x1f);
					DEP(rs);
					DEP(rt);
					TGPR(temp_14, rs);
					TGPR(temp_15, rt);
					DO_LDS();
					uint64_t _t = ((int64_t) ((int32_t) (temp_14))) * ((int64_t) ((int32_t) (temp_15)));
					LO() = (uint32_t) (_t);
					HI() = (uint32_t) ((_t) >> (0x20));
					mul_delay(temp_14, temp_15, 0x1);
					return(true);
					break;
				}
				case 0x19: {
					/* MULTU */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t rt = ((inst) >> (0x10)) & (0x1f);
					DEP(rs);
					DEP(rt);
					TGPR(temp_16, rs);
					TGPR(temp_17, rt);
					DO_LDS();
					uint64_t _t = ((uint64_t) (temp_16)) * ((uint64_t) (temp_17));
					LO() = (uint32_t) (_t);
					HI() = (uint32_t) ((_t) >> (0x20));
					mul_delay(temp_16, temp_17, 0x0);
					return(true);
					break;
				}
				case 0x1a: {
					/* DIV */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t rt = ((inst) >> (0x10)) & (0x1f);
					DEP(rs);
					DEP(rt);
					TGPR(temp_18, rs);
					TGPR(temp_19, rt);
					DO_LDS();
					if((temp_19) == (0x0)) {
						if(((temp_18) & (0x80000000)) != (0x0)) {
							LO() = 0x1;
						} else {
							LO() = 0xffffffff;
						}
						HI() = temp_18;
					} else {
						if(((temp_18) == (0x80000000)) & ((temp_19) == (0xffffffff))) {
							LO() = 0x80000000;
							HI() = 0x0;
						} else {
							LO() = ((int32_t) (temp_18)) / ((int32_t) (temp_19));
							HI() = ((int32_t) (temp_18)) % ((int32_t) (temp_19));
							div_delay();
						}
					}
					return(true);
					break;
				}
				case 0x1b: {
					/* DIVU */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t rt = ((inst) >> (0x10)) & (0x1f);
					DEP(rs);
					DEP(rt);
					TGPR(temp_20, rs);
					TGPR(temp_21, rt);
					DO_LDS();
					if((temp_21) == (0x0)) {
						LO() = 0xffffffff;
						HI() = temp_20;
					} else {
						LO() = (temp_20) / (temp_21);
						HI() = (temp_20) % (temp_21);
						div_delay();
					}
					return(true);
					break;
				}
				case 0x20: {
					/* ADD */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t rt = ((inst) >> (0x10)) & (0x1f);
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					DEP(rs);
					DEP(rt);
					RES(rd);
					TGPR(temp_22, rs);
					TGPR(temp_23, rt);
					DO_LDS();
					overflow(temp_22, temp_23, 0x1, pc, inst);
					if((rd) != (0x0)) { REG(rd) = (temp_22) + (temp_23); }
					return(true);
					break;
				}
				case 0x21: {
					/* ADDU */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t rt = ((inst) >> (0x10)) & (0x1f);
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					DEP(rs);
					DEP(rt);
					RES(rd);
					TGPR(temp_24, rs);
					TGPR(temp_25, rt);
					DO_LDS();
					if((rd) != (0x0)) { REG(rd) = (temp_24) + (temp_25); }
					return(true);
					break;
				}
				case 0x22: {
					/* SUB */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t rt = ((inst) >> (0x10)) & (0x1f);
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					DEP(rs);
					DEP(rt);
					RES(rd);
					TGPR(temp_26, rs);
					TGPR(temp_27, rt);
					DO_LDS();
					overflow(temp_26, temp_27, -0x1, pc, inst);
					if((rd) != (0x0)) { REG(rd) = (temp_26) - (temp_27); }
					return(true);
					break;
				}
				case 0x23: {
					/* SUBU */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t rt = ((inst) >> (0x10)) & (0x1f);
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					DEP(rs);
					DEP(rt);
					RES(rd);
					TGPR(temp_28, rs);
					TGPR(temp_29, rt);
					DO_LDS();
					if((rd) != (0x0)) { REG(rd) = (temp_28) - (temp_29); }
					return(true);
					break;
				}
				case 0x24: {
					/* AND */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t rt = ((inst) >> (0x10)) & (0x1f);
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					DEP(rs);
					DEP(rt);
					RES(rd);
					TGPR(temp_30, rs);
					TGPR(temp_31, rt);
					DO_LDS();
					if((rd) != (0x0)) { REG(rd) = (temp_30) & (temp_31); }
					return(true);
					break;
				}
				case 0x25: {
					/* OR */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t rt = ((inst) >> (0x10)) & (0x1f);
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					DEP(rs);
					DEP(rt);
					RES(rd);
					TGPR(temp_32, rs);
					TGPR(temp_33, rt);
					DO_LDS();
					if((rd) != (0x0)) { REG(rd) = (temp_32) | (temp_33); }
					return(true);
					break;
				}
				case 0x26: {
					/* XOR */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t rt = ((inst) >> (0x10)) & (0x1f);
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					DEP(rs);
					DEP(rt);
					RES(rd);
					TGPR(temp_34, rs);
					TGPR(temp_35, rt);
					DO_LDS();
					if((rd) != (0x0)) { REG(rd) = (temp_34) ^ (temp_35); }
					return(true);
					break;
				}
				case 0x27: {
					/* NOR */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t rt = ((inst) >> (0x10)) & (0x1f);
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					DEP(rs);
					DEP(rt);
					RES(rd);
					TGPR(temp_36, rs);
					TGPR(temp_37, rt);
					DO_LDS();
					if((rd) != (0x0)) { REG(rd) = ~((temp_36) | (temp_37)); }
					return(true);
					break;
				}
				case 0x2a: {
					/* SLT */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t rt = ((inst) >> (0x10)) & (0x1f);
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					DEP(rs);
					DEP(rt);
					RES(rd);
					TGPR(temp_38, rs);
					TGPR(temp_39, rt);
					DO_LDS();
					if((rd) != (0x0)) { REG(rd) = ((int32_t) (temp_38)) < ((int32_t) (temp_39)); }
					return(true);
					break;
				}
				case 0x2b: {
					/* SLTU */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t rt = ((inst) >> (0x10)) & (0x1f);
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					DEP(rs);
					DEP(rt);
					RES(rd);
					TGPR(temp_40, rs);
					TGPR(temp_41, rt);
					DO_LDS();
					if((rd) != (0x0)) { REG(rd) = (temp_40) < (temp_41); }
					return(true);
					break;
				}
			}
			break;
		}
		case 0x1: {
			switch(((inst) >> (0x10)) & (0x1f)) {
				case 0x0: {
					/* BLTZanonymous_0 */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t imm = (inst) & (0xffff);
					DEP(rs);
					TGPR(temp_42, rs);
					DO_LDS();
					uint32_t target = ((pc) + (0x4)) + ((signext(0x10, imm)) << (0x2));
					if(((int32_t) (temp_42)) < (0x0)) {
						alignment(target, 0x20, 0x0, pc);
						branch_to = target;
					} else {
						branch_default();
					}
					return(true);
					break;
				}
				case 0x1: {
					/* BGEZanonymous_0 */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t imm = (inst) & (0xffff);
					DEP(rs);
					TGPR(temp_43, rs);
					DO_LDS();
					uint32_t target = ((pc) + (0x4)) + ((signext(0x10, imm)) << (0x2));
					if(((int32_t) (temp_43)) >= (0x0)) {
						alignment(target, 0x20, 0x0, pc);
						branch_to = target;
					} else {
						branch_default();
					}
					return(true);
					break;
				}
				case 0x2: {
					/* BLTZanonymous_1 */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t imm = (inst) & (0xffff);
					DEP(rs);
					TGPR(temp_44, rs);
					DO_LDS();
					uint32_t target = ((pc) + (0x4)) + ((signext(0x10, imm)) << (0x2));
					if(((int32_t) (temp_44)) < (0x0)) {
						alignment(target, 0x20, 0x0, pc);
						branch_to = target;
					} else {
						branch_default();
					}
					return(true);
					break;
				}
				case 0x3: {
					/* BGEZanonymous_1 */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t imm = (inst) & (0xffff);
					DEP(rs);
					TGPR(temp_45, rs);
					DO_LDS();
					uint32_t target = ((pc) + (0x4)) + ((signext(0x10, imm)) << (0x2));
					if(((int32_t) (temp_45)) >= (0x0)) {
						alignment(target, 0x20, 0x0, pc);
						branch_to = target;
					} else {
						branch_default();
					}
					return(true);
					break;
				}
				case 0x4: {
					/* BLTZanonymous_2 */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t imm = (inst) & (0xffff);
					DEP(rs);
					TGPR(temp_46, rs);
					DO_LDS();
					uint32_t target = ((pc) + (0x4)) + ((signext(0x10, imm)) << (0x2));
					if(((int32_t) (temp_46)) < (0x0)) {
						alignment(target, 0x20, 0x0, pc);
						branch_to = target;
					} else {
						branch_default();
					}
					return(true);
					break;
				}
				case 0x5: {
					/* BGEZanonymous_2 */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t imm = (inst) & (0xffff);
					DEP(rs);
					TGPR(temp_47, rs);
					DO_LDS();
					uint32_t target = ((pc) + (0x4)) + ((signext(0x10, imm)) << (0x2));
					if(((int32_t) (temp_47)) >= (0x0)) {
						alignment(target, 0x20, 0x0, pc);
						branch_to = target;
					} else {
						branch_default();
					}
					return(true);
					break;
				}
				case 0x6: {
					/* BLTZanonymous_3 */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t imm = (inst) & (0xffff);
					DEP(rs);
					TGPR(temp_48, rs);
					DO_LDS();
					uint32_t target = ((pc) + (0x4)) + ((signext(0x10, imm)) << (0x2));
					if(((int32_t) (temp_48)) < (0x0)) {
						alignment(target, 0x20, 0x0, pc);
						branch_to = target;
					} else {
						branch_default();
					}
					return(true);
					break;
				}
				case 0x7: {
					/* BGEZanonymous_3 */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t imm = (inst) & (0xffff);
					DEP(rs);
					TGPR(temp_49, rs);
					DO_LDS();
					uint32_t target = ((pc) + (0x4)) + ((signext(0x10, imm)) << (0x2));
					if(((int32_t) (temp_49)) >= (0x0)) {
						alignment(target, 0x20, 0x0, pc);
						branch_to = target;
					} else {
						branch_default();
					}
					return(true);
					break;
				}
				case 0x8: {
					/* BLTZanonymous_4 */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t imm = (inst) & (0xffff);
					DEP(rs);
					TGPR(temp_50, rs);
					DO_LDS();
					uint32_t target = ((pc) + (0x4)) + ((signext(0x10, imm)) << (0x2));
					if(((int32_t) (temp_50)) < (0x0)) {
						alignment(target, 0x20, 0x0, pc);
						branch_to = target;
					} else {
						branch_default();
					}
					return(true);
					break;
				}
				case 0x9: {
					/* BGEZanonymous_4 */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t imm = (inst) & (0xffff);
					DEP(rs);
					TGPR(temp_51, rs);
					DO_LDS();
					uint32_t target = ((pc) + (0x4)) + ((signext(0x10, imm)) << (0x2));
					if(((int32_t) (temp_51)) >= (0x0)) {
						alignment(target, 0x20, 0x0, pc);
						branch_to = target;
					} else {
						branch_default();
					}
					return(true);
					break;
				}
				case 0xa: {
					/* BLTZanonymous_5 */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t imm = (inst) & (0xffff);
					DEP(rs);
					TGPR(temp_52, rs);
					DO_LDS();
					uint32_t target = ((pc) + (0x4)) + ((signext(0x10, imm)) << (0x2));
					if(((int32_t) (temp_52)) < (0x0)) {
						alignment(target, 0x20, 0x0, pc);
						branch_to = target;
					} else {
						branch_default();
					}
					return(true);
					break;
				}
				case 0xb: {
					/* BGEZanonymous_5 */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t imm = (inst) & (0xffff);
					DEP(rs);
					TGPR(temp_53, rs);
					DO_LDS();
					uint32_t target = ((pc) + (0x4)) + ((signext(0x10, imm)) << (0x2));
					if(((int32_t) (temp_53)) >= (0x0)) {
						alignment(target, 0x20, 0x0, pc);
						branch_to = target;
					} else {
						branch_default();
					}
					return(true);
					break;
				}
				case 0xc: {
					/* BLTZanonymous_6 */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t imm = (inst) & (0xffff);
					DEP(rs);
					TGPR(temp_54, rs);
					DO_LDS();
					uint32_t target = ((pc) + (0x4)) + ((signext(0x10, imm)) << (0x2));
					if(((int32_t) (temp_54)) < (0x0)) {
						alignment(target, 0x20, 0x0, pc);
						branch_to = target;
					} else {
						branch_default();
					}
					return(true);
					break;
				}
				case 0xd: {
					/* BGEZanonymous_6 */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t imm = (inst) & (0xffff);
					DEP(rs);
					TGPR(temp_55, rs);
					DO_LDS();
					uint32_t target = ((pc) + (0x4)) + ((signext(0x10, imm)) << (0x2));
					if(((int32_t) (temp_55)) >= (0x0)) {
						alignment(target, 0x20, 0x0, pc);
						branch_to = target;
					} else {
						branch_default();
					}
					return(true);
					break;
				}
				case 0xe: {
					/* BLTZanonymous_7 */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t imm = (inst) & (0xffff);
					DEP(rs);
					TGPR(temp_56, rs);
					DO_LDS();
					uint32_t target = ((pc) + (0x4)) + ((signext(0x10, imm)) << (0x2));
					if(((int32_t) (temp_56)) < (0x0)) {
						alignment(target, 0x20, 0x0, pc);
						branch_to = target;
					} else {
						branch_default();
					}
					return(true);
					break;
				}
				case 0xf: {
					/* BGEZanonymous_7 */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t imm = (inst) & (0xffff);
					DEP(rs);
					TGPR(temp_57, rs);
					DO_LDS();
					uint32_t target = ((pc) + (0x4)) + ((signext(0x10, imm)) << (0x2));
					if(((int32_t) (temp_57)) >= (0x0)) {
						alignment(target, 0x20, 0x0, pc);
						branch_to = target;
					} else {
						branch_default();
					}
					return(true);
					break;
				}
				case 0x10: {
					/* BLTZALanonymous_0 */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t imm = (inst) & (0xffff);
					DEP(rs);
					RES(0x1f);
					TGPR(temp_58, rs);
					DO_LDS();
					if((0x1f) != (0x0)) { REG(0x1f) = ((pc) + (0x4)) + (0x4); }
					uint32_t target = ((pc) + (0x4)) + ((signext(0x10, imm)) << (0x2));
					if(((int32_t) (temp_58)) < (0x0)) {
						alignment(target, 0x20, 0x0, pc);
						branch_to = target;
					} else {
						branch_default();
					}
					return(true);
					break;
				}
				case 0x11: {
					/* BGEZALanonymous_0 */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t imm = (inst) & (0xffff);
					DEP(rs);
					RES(0x1f);
					TGPR(temp_59, rs);
					DO_LDS();
					if((0x1f) != (0x0)) { REG(0x1f) = ((pc) + (0x4)) + (0x4); }
					uint32_t target = ((pc) + (0x4)) + ((signext(0x10, imm)) << (0x2));
					if(((int32_t) (temp_59)) >= (0x0)) {
						alignment(target, 0x20, 0x0, pc);
						branch_to = target;
					} else {
						branch_default();
					}
					return(true);
					break;
				}
				case 0x12: {
					/* BLTZALanonymous_1 */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t imm = (inst) & (0xffff);
					DEP(rs);
					RES(0x1f);
					TGPR(temp_60, rs);
					DO_LDS();
					if((0x1f) != (0x0)) { REG(0x1f) = ((pc) + (0x4)) + (0x4); }
					uint32_t target = ((pc) + (0x4)) + ((signext(0x10, imm)) << (0x2));
					if(((int32_t) (temp_60)) < (0x0)) {
						alignment(target, 0x20, 0x0, pc);
						branch_to = target;
					} else {
						branch_default();
					}
					return(true);
					break;
				}
				case 0x13: {
					/* BGEZALanonymous_1 */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t imm = (inst) & (0xffff);
					DEP(rs);
					RES(0x1f);
					TGPR(temp_61, rs);
					DO_LDS();
					if((0x1f) != (0x0)) { REG(0x1f) = ((pc) + (0x4)) + (0x4); }
					uint32_t target = ((pc) + (0x4)) + ((signext(0x10, imm)) << (0x2));
					if(((int32_t) (temp_61)) >= (0x0)) {
						alignment(target, 0x20, 0x0, pc);
						branch_to = target;
					} else {
						branch_default();
					}
					return(true);
					break;
				}
				case 0x14: {
					/* BLTZALanonymous_2 */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t imm = (inst) & (0xffff);
					DEP(rs);
					RES(0x1f);
					TGPR(temp_62, rs);
					DO_LDS();
					if((0x1f) != (0x0)) { REG(0x1f) = ((pc) + (0x4)) + (0x4); }
					uint32_t target = ((pc) + (0x4)) + ((signext(0x10, imm)) << (0x2));
					if(((int32_t) (temp_62)) < (0x0)) {
						alignment(target, 0x20, 0x0, pc);
						branch_to = target;
					} else {
						branch_default();
					}
					return(true);
					break;
				}
				case 0x15: {
					/* BGEZALanonymous_2 */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t imm = (inst) & (0xffff);
					DEP(rs);
					RES(0x1f);
					TGPR(temp_63, rs);
					DO_LDS();
					if((0x1f) != (0x0)) { REG(0x1f) = ((pc) + (0x4)) + (0x4); }
					uint32_t target = ((pc) + (0x4)) + ((signext(0x10, imm)) << (0x2));
					if(((int32_t) (temp_63)) >= (0x0)) {
						alignment(target, 0x20, 0x0, pc);
						branch_to = target;
					} else {
						branch_default();
					}
					return(true);
					break;
				}
				case 0x16: {
					/* BLTZALanonymous_3 */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t imm = (inst) & (0xffff);
					DEP(rs);
					RES(0x1f);
					TGPR(temp_64, rs);
					DO_LDS();
					if((0x1f) != (0x0)) { REG(0x1f) = ((pc) + (0x4)) + (0x4); }
					uint32_t target = ((pc) + (0x4)) + ((signext(0x10, imm)) << (0x2));
					if(((int32_t) (temp_64)) < (0x0)) {
						alignment(target, 0x20, 0x0, pc);
						branch_to = target;
					} else {
						branch_default();
					}
					return(true);
					break;
				}
				case 0x17: {
					/* BGEZALanonymous_3 */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t imm = (inst) & (0xffff);
					DEP(rs);
					RES(0x1f);
					TGPR(temp_65, rs);
					DO_LDS();
					if((0x1f) != (0x0)) { REG(0x1f) = ((pc) + (0x4)) + (0x4); }
					uint32_t target = ((pc) + (0x4)) + ((signext(0x10, imm)) << (0x2));
					if(((int32_t) (temp_65)) >= (0x0)) {
						alignment(target, 0x20, 0x0, pc);
						branch_to = target;
					} else {
						branch_default();
					}
					return(true);
					break;
				}
				case 0x18: {
					/* BLTZALanonymous_4 */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t imm = (inst) & (0xffff);
					DEP(rs);
					RES(0x1f);
					TGPR(temp_66, rs);
					DO_LDS();
					if((0x1f) != (0x0)) { REG(0x1f) = ((pc) + (0x4)) + (0x4); }
					uint32_t target = ((pc) + (0x4)) + ((signext(0x10, imm)) << (0x2));
					if(((int32_t) (temp_66)) < (0x0)) {
						alignment(target, 0x20, 0x0, pc);
						branch_to = target;
					} else {
						branch_default();
					}
					return(true);
					break;
				}
				case 0x19: {
					/* BGEZALanonymous_4 */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t imm = (inst) & (0xffff);
					DEP(rs);
					RES(0x1f);
					TGPR(temp_67, rs);
					DO_LDS();
					if((0x1f) != (0x0)) { REG(0x1f) = ((pc) + (0x4)) + (0x4); }
					uint32_t target = ((pc) + (0x4)) + ((signext(0x10, imm)) << (0x2));
					if(((int32_t) (temp_67)) >= (0x0)) {
						alignment(target, 0x20, 0x0, pc);
						branch_to = target;
					} else {
						branch_default();
					}
					return(true);
					break;
				}
				case 0x1a: {
					/* BLTZALanonymous_5 */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t imm = (inst) & (0xffff);
					DEP(rs);
					RES(0x1f);
					TGPR(temp_68, rs);
					DO_LDS();
					if((0x1f) != (0x0)) { REG(0x1f) = ((pc) + (0x4)) + (0x4); }
					uint32_t target = ((pc) + (0x4)) + ((signext(0x10, imm)) << (0x2));
					if(((int32_t) (temp_68)) < (0x0)) {
						alignment(target, 0x20, 0x0, pc);
						branch_to = target;
					} else {
						branch_default();
					}
					return(true);
					break;
				}
				case 0x1b: {
					/* BGEZALanonymous_5 */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t imm = (inst) & (0xffff);
					DEP(rs);
					RES(0x1f);
					TGPR(temp_69, rs);
					DO_LDS();
					if((0x1f) != (0x0)) { REG(0x1f) = ((pc) + (0x4)) + (0x4); }
					uint32_t target = ((pc) + (0x4)) + ((signext(0x10, imm)) << (0x2));
					if(((int32_t) (temp_69)) >= (0x0)) {
						alignment(target, 0x20, 0x0, pc);
						branch_to = target;
					} else {
						branch_default();
					}
					return(true);
					break;
				}
				case 0x1c: {
					/* BLTZALanonymous_6 */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t imm = (inst) & (0xffff);
					DEP(rs);
					RES(0x1f);
					TGPR(temp_70, rs);
					DO_LDS();
					if((0x1f) != (0x0)) { REG(0x1f) = ((pc) + (0x4)) + (0x4); }
					uint32_t target = ((pc) + (0x4)) + ((signext(0x10, imm)) << (0x2));
					if(((int32_t) (temp_70)) < (0x0)) {
						alignment(target, 0x20, 0x0, pc);
						branch_to = target;
					} else {
						branch_default();
					}
					return(true);
					break;
				}
				case 0x1d: {
					/* BGEZALanonymous_6 */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t imm = (inst) & (0xffff);
					DEP(rs);
					RES(0x1f);
					TGPR(temp_71, rs);
					DO_LDS();
					if((0x1f) != (0x0)) { REG(0x1f) = ((pc) + (0x4)) + (0x4); }
					uint32_t target = ((pc) + (0x4)) + ((signext(0x10, imm)) << (0x2));
					if(((int32_t) (temp_71)) >= (0x0)) {
						alignment(target, 0x20, 0x0, pc);
						branch_to = target;
					} else {
						branch_default();
					}
					return(true);
					break;
				}
				case 0x1e: {
					/* BLTZALanonymous_7 */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t imm = (inst) & (0xffff);
					DEP(rs);
					RES(0x1f);
					TGPR(temp_72, rs);
					DO_LDS();
					if((0x1f) != (0x0)) { REG(0x1f) = ((pc) + (0x4)) + (0x4); }
					uint32_t target = ((pc) + (0x4)) + ((signext(0x10, imm)) << (0x2));
					if(((int32_t) (temp_72)) < (0x0)) {
						alignment(target, 0x20, 0x0, pc);
						branch_to = target;
					} else {
						branch_default();
					}
					return(true);
					break;
				}
				case 0x1f: {
					/* BGEZALanonymous_7 */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t imm = (inst) & (0xffff);
					DEP(rs);
					RES(0x1f);
					TGPR(temp_73, rs);
					DO_LDS();
					if((0x1f) != (0x0)) { REG(0x1f) = ((pc) + (0x4)) + (0x4); }
					uint32_t target = ((pc) + (0x4)) + ((signext(0x10, imm)) << (0x2));
					if(((int32_t) (temp_73)) >= (0x0)) {
						alignment(target, 0x20, 0x0, pc);
						branch_to = target;
					} else {
						branch_default();
					}
					return(true);
					break;
				}
			}
			break;
		}
		case 0x2: {
			/* J */
			uint32_t imm = (inst) & (0x3ffffff);
			DO_LDS();
			uint32_t target = (((pc) + (0x4)) & (0xf0000000)) + ((imm) << (0x2));
			alignment(target, 0x20, 0x0, pc);
			branch_to = target;
			return(true);
			break;
		}
		case 0x3: {
			/* JAL */
			uint32_t imm = (inst) & (0x3ffffff);
			RES(0x1f);
			DO_LDS();
			if((0x1f) != (0x0)) { REG(0x1f) = ((pc) + (0x4)) + (0x4); }
			uint32_t target = (((pc) + (0x4)) & (0xf0000000)) + ((imm) << (0x2));
			alignment(target, 0x20, 0x0, pc);
			branch_to = target;
			return(true);
			break;
		}
		case 0x4: {
			/* BEQ */
			uint32_t rs = ((inst) >> (0x15)) & (0x1f);
			uint32_t rt = ((inst) >> (0x10)) & (0x1f);
			uint32_t imm = (inst) & (0xffff);
			DEP(rs);
			DEP(rt);
			TGPR(temp_74, rs);
			TGPR(temp_75, rt);
			DO_LDS();
			uint32_t target = ((pc) + (0x4)) + ((signext(0x10, imm)) << (0x2));
			if((temp_74) == (temp_75)) {
				alignment(target, 0x20, 0x0, pc);
				branch_to = target;
			} else {
				branch_default();
			}
			return(true);
			break;
		}
		case 0x5: {
			/* BNE */
			uint32_t rs = ((inst) >> (0x15)) & (0x1f);
			uint32_t rt = ((inst) >> (0x10)) & (0x1f);
			uint32_t imm = (inst) & (0xffff);
			DEP(rs);
			DEP(rt);
			TGPR(temp_76, rs);
			TGPR(temp_77, rt);
			DO_LDS();
			uint32_t target = ((pc) + (0x4)) + ((signext(0x10, imm)) << (0x2));
			if((temp_76) != (temp_77)) {
				alignment(target, 0x20, 0x0, pc);
				branch_to = target;
			} else {
				branch_default();
			}
			return(true);
			break;
		}
		case 0x6: {
			switch(((inst) >> (0x10)) & (0x1f)) {
				case 0x0: {
					/* BLEZ */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t imm = (inst) & (0xffff);
					DEP(rs);
					TGPR(temp_78, rs);
					DO_LDS();
					uint32_t target = ((pc) + (0x4)) + ((signext(0x10, imm)) << (0x2));
					if(((int32_t) (temp_78)) <= (0x0)) {
						alignment(target, 0x20, 0x0, pc);
						branch_to = target;
					} else {
						branch_default();
					}
					return(true);
					break;
				}
			}
			break;
		}
		case 0x7: {
			switch(((inst) >> (0x10)) & (0x1f)) {
				case 0x0: {
					/* BGTZ */
					uint32_t rs = ((inst) >> (0x15)) & (0x1f);
					uint32_t imm = (inst) & (0xffff);
					DEP(rs);
					TGPR(temp_79, rs);
					DO_LDS();
					uint32_t target = ((pc) + (0x4)) + ((signext(0x10, imm)) << (0x2));
					if(((int32_t) (temp_79)) > (0x0)) {
						alignment(target, 0x20, 0x0, pc);
						branch_to = target;
					} else {
						branch_default();
					}
					return(true);
					break;
				}
			}
			break;
		}
		case 0x8: {
			/* ADDI */
			uint32_t rs = ((inst) >> (0x15)) & (0x1f);
			uint32_t rt = ((inst) >> (0x10)) & (0x1f);
			uint32_t imm = (inst) & (0xffff);
			DEP(rs);
			RES(rt);
			TGPR(temp_80, rs);
			DO_LDS();
			uint32_t eimm = signext(0x10, imm);
			overflow(temp_80, eimm, 0x1, pc, inst);
			if((rt) != (0x0)) { REG(rt) = (temp_80) + (eimm); }
			return(true);
			break;
		}
		case 0x9: {
			/* ADDIU */
			uint32_t rs = ((inst) >> (0x15)) & (0x1f);
			uint32_t rt = ((inst) >> (0x10)) & (0x1f);
			uint32_t imm = (inst) & (0xffff);
			DEP(rs);
			RES(rt);
			TGPR(temp_81, rs);
			DO_LDS();
			uint32_t eimm = signext(0x10, imm);
			if((rt) != (0x0)) { REG(rt) = (temp_81) + (eimm); }
			return(true);
			break;
		}
		case 0xa: {
			/* SLTI */
			uint32_t rs = ((inst) >> (0x15)) & (0x1f);
			uint32_t rt = ((inst) >> (0x10)) & (0x1f);
			uint32_t imm = (inst) & (0xffff);
			DEP(rs);
			RES(rt);
			TGPR(temp_82, rs);
			DO_LDS();
			uint32_t eimm = signext(0x10, imm);
			if((rt) != (0x0)) { REG(rt) = ((int32_t) (temp_82)) < ((int32_t) (eimm)); }
			return(true);
			break;
		}
		case 0xb: {
			/* SLTIU */
			uint32_t rs = ((inst) >> (0x15)) & (0x1f);
			uint32_t rt = ((inst) >> (0x10)) & (0x1f);
			uint32_t imm = (inst) & (0xffff);
			DEP(rs);
			RES(rt);
			TGPR(temp_83, rs);
			DO_LDS();
			uint32_t eimm = signext(0x10, imm);
			if((rt) != (0x0)) { REG(rt) = (temp_83) < (eimm); }
			return(true);
			break;
		}
		case 0xc: {
			/* ANDI */
			uint32_t rs = ((inst) >> (0x15)) & (0x1f);
			uint32_t rt = ((inst) >> (0x10)) & (0x1f);
			uint32_t imm = (inst) & (0xffff);
			DEP(rs);
			RES(rt);
			TGPR(temp_84, rs);
			DO_LDS();
			uint32_t eimm = imm;
			if((rt) != (0x0)) { REG(rt) = (temp_84) & (eimm); }
			return(true);
			break;
		}
		case 0xd: {
			/* ORI */
			uint32_t rs = ((inst) >> (0x15)) & (0x1f);
			uint32_t rt = ((inst) >> (0x10)) & (0x1f);
			uint32_t imm = (inst) & (0xffff);
			DEP(rs);
			RES(rt);
			TGPR(temp_85, rs);
			DO_LDS();
			uint32_t eimm = imm;
			if((rt) != (0x0)) { REG(rt) = (temp_85) | (eimm); }
			return(true);
			break;
		}
		case 0xe: {
			/* XORI */
			uint32_t rs = ((inst) >> (0x15)) & (0x1f);
			uint32_t rt = ((inst) >> (0x10)) & (0x1f);
			uint32_t imm = (inst) & (0xffff);
			DEP(rs);
			RES(rt);
			TGPR(temp_86, rs);
			DO_LDS();
			uint32_t eimm = imm;
			if((rt) != (0x0)) { REG(rt) = (temp_86) ^ (eimm); }
			return(true);
			break;
		}
		case 0xf: {
			/* LUI */
			uint32_t rt = ((inst) >> (0x10)) & (0x1f);
			uint32_t imm = (inst) & (0xffff);
			RES(rt);
			DO_LDS();
			if((rt) != (0x0)) { REG(rt) = (imm) << (0x10); }
			return(true);
			break;
		}
		case 0x10: {
			switch(((inst) >> (0x15)) & (0x1f)) {
				case 0x0: {
					/* MFCzanonymous_8 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t rt = ((inst) >> (0x10)) & (0x1f);
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					RES(rt);
					DO_LDS();
					if((rt) != (0x0)) { DEFER_SET(rt, read_copreg(cop, rd)); }
					return(true);
					break;
				}
				case 0x2: {
					/* CFCzanonymous_8 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t rt = ((inst) >> (0x10)) & (0x1f);
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					RES(rt);
					DO_LDS();
					if((rt) != (0x0)) { REG(rt) = read_copcreg(cop, rd); }
					return(true);
					break;
				}
				case 0x4: {
					/* MTCzanonymous_8 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t rt = ((inst) >> (0x10)) & (0x1f);
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					DEP(rt);
					TGPR(temp_87, rt);
					DO_LDS();
					write_copreg(cop, rd, temp_87);
					return(true);
					break;
				}
				case 0x6: {
					/* CTCzanonymous_8 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t rt = ((inst) >> (0x10)) & (0x1f);
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					DEP(rt);
					TGPR(temp_88, rt);
					DO_LDS();
					write_copcreg(cop, rd, temp_88);
					return(true);
					break;
				}
				case 0x10: {
					/* COPzanonymous_12anonymous_8 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x11: {
					/* COPzanonymous_13anonymous_8 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x12: {
					/* COPzanonymous_14anonymous_8 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x13: {
					/* COPzanonymous_15anonymous_8 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x14: {
					/* COPzanonymous_16anonymous_8 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x15: {
					/* COPzanonymous_17anonymous_8 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x16: {
					/* COPzanonymous_18anonymous_8 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x17: {
					/* COPzanonymous_19anonymous_8 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x18: {
					/* COPzanonymous_20anonymous_8 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x19: {
					/* COPzanonymous_21anonymous_8 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x1a: {
					/* COPzanonymous_22anonymous_8 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x1b: {
					/* COPzanonymous_23anonymous_8 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x1c: {
					/* COPzanonymous_24anonymous_8 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x1d: {
					/* COPzanonymous_25anonymous_8 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x1e: {
					/* COPzanonymous_26anonymous_8 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x1f: {
					/* COPzanonymous_27anonymous_8 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
			}
			break;
		}
		case 0x11: {
			switch(((inst) >> (0x15)) & (0x1f)) {
				case 0x0: {
					/* MFCzanonymous_9 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t rt = ((inst) >> (0x10)) & (0x1f);
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					RES(rt);
					DO_LDS();
					if((rt) != (0x0)) { DEFER_SET(rt, read_copreg(cop, rd)); }
					return(true);
					break;
				}
				case 0x2: {
					/* CFCzanonymous_9 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t rt = ((inst) >> (0x10)) & (0x1f);
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					RES(rt);
					DO_LDS();
					if((rt) != (0x0)) { REG(rt) = read_copcreg(cop, rd); }
					return(true);
					break;
				}
				case 0x4: {
					/* MTCzanonymous_9 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t rt = ((inst) >> (0x10)) & (0x1f);
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					DEP(rt);
					TGPR(temp_89, rt);
					DO_LDS();
					write_copreg(cop, rd, temp_89);
					return(true);
					break;
				}
				case 0x6: {
					/* CTCzanonymous_9 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t rt = ((inst) >> (0x10)) & (0x1f);
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					DEP(rt);
					TGPR(temp_90, rt);
					DO_LDS();
					write_copcreg(cop, rd, temp_90);
					return(true);
					break;
				}
				case 0x10: {
					/* COPzanonymous_12anonymous_9 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x11: {
					/* COPzanonymous_13anonymous_9 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x12: {
					/* COPzanonymous_14anonymous_9 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x13: {
					/* COPzanonymous_15anonymous_9 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x14: {
					/* COPzanonymous_16anonymous_9 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x15: {
					/* COPzanonymous_17anonymous_9 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x16: {
					/* COPzanonymous_18anonymous_9 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x17: {
					/* COPzanonymous_19anonymous_9 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x18: {
					/* COPzanonymous_20anonymous_9 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x19: {
					/* COPzanonymous_21anonymous_9 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x1a: {
					/* COPzanonymous_22anonymous_9 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x1b: {
					/* COPzanonymous_23anonymous_9 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x1c: {
					/* COPzanonymous_24anonymous_9 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x1d: {
					/* COPzanonymous_25anonymous_9 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x1e: {
					/* COPzanonymous_26anonymous_9 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x1f: {
					/* COPzanonymous_27anonymous_9 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
			}
			break;
		}
		case 0x12: {
			switch(((inst) >> (0x15)) & (0x1f)) {
				case 0x0: {
					/* MFCzanonymous_10 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t rt = ((inst) >> (0x10)) & (0x1f);
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					RES(rt);
					DO_LDS();
					if((rt) != (0x0)) { DEFER_SET(rt, read_copreg(cop, rd)); }
					return(true);
					break;
				}
				case 0x2: {
					/* CFCzanonymous_10 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t rt = ((inst) >> (0x10)) & (0x1f);
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					RES(rt);
					DO_LDS();
					if((rt) != (0x0)) { REG(rt) = read_copcreg(cop, rd); }
					return(true);
					break;
				}
				case 0x4: {
					/* MTCzanonymous_10 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t rt = ((inst) >> (0x10)) & (0x1f);
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					DEP(rt);
					TGPR(temp_91, rt);
					DO_LDS();
					write_copreg(cop, rd, temp_91);
					return(true);
					break;
				}
				case 0x6: {
					/* CTCzanonymous_10 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t rt = ((inst) >> (0x10)) & (0x1f);
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					DEP(rt);
					TGPR(temp_92, rt);
					DO_LDS();
					write_copcreg(cop, rd, temp_92);
					return(true);
					break;
				}
				case 0x10: {
					/* COPzanonymous_12anonymous_10 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x11: {
					/* COPzanonymous_13anonymous_10 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x12: {
					/* COPzanonymous_14anonymous_10 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x13: {
					/* COPzanonymous_15anonymous_10 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x14: {
					/* COPzanonymous_16anonymous_10 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x15: {
					/* COPzanonymous_17anonymous_10 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x16: {
					/* COPzanonymous_18anonymous_10 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x17: {
					/* COPzanonymous_19anonymous_10 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x18: {
					/* COPzanonymous_20anonymous_10 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x19: {
					/* COPzanonymous_21anonymous_10 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x1a: {
					/* COPzanonymous_22anonymous_10 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x1b: {
					/* COPzanonymous_23anonymous_10 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x1c: {
					/* COPzanonymous_24anonymous_10 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x1d: {
					/* COPzanonymous_25anonymous_10 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x1e: {
					/* COPzanonymous_26anonymous_10 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x1f: {
					/* COPzanonymous_27anonymous_10 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
			}
			break;
		}
		case 0x13: {
			switch(((inst) >> (0x15)) & (0x1f)) {
				case 0x0: {
					/* MFCzanonymous_11 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t rt = ((inst) >> (0x10)) & (0x1f);
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					RES(rt);
					DO_LDS();
					if((rt) != (0x0)) { DEFER_SET(rt, read_copreg(cop, rd)); }
					return(true);
					break;
				}
				case 0x2: {
					/* CFCzanonymous_11 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t rt = ((inst) >> (0x10)) & (0x1f);
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					RES(rt);
					DO_LDS();
					if((rt) != (0x0)) { REG(rt) = read_copcreg(cop, rd); }
					return(true);
					break;
				}
				case 0x4: {
					/* MTCzanonymous_11 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t rt = ((inst) >> (0x10)) & (0x1f);
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					DEP(rt);
					TGPR(temp_93, rt);
					DO_LDS();
					write_copreg(cop, rd, temp_93);
					return(true);
					break;
				}
				case 0x6: {
					/* CTCzanonymous_11 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t rt = ((inst) >> (0x10)) & (0x1f);
					uint32_t rd = ((inst) >> (0xb)) & (0x1f);
					DEP(rt);
					TGPR(temp_94, rt);
					DO_LDS();
					write_copcreg(cop, rd, temp_94);
					return(true);
					break;
				}
				case 0x10: {
					/* COPzanonymous_12anonymous_11 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x11: {
					/* COPzanonymous_13anonymous_11 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x12: {
					/* COPzanonymous_14anonymous_11 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x13: {
					/* COPzanonymous_15anonymous_11 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x14: {
					/* COPzanonymous_16anonymous_11 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x15: {
					/* COPzanonymous_17anonymous_11 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x16: {
					/* COPzanonymous_18anonymous_11 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x17: {
					/* COPzanonymous_19anonymous_11 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x18: {
					/* COPzanonymous_20anonymous_11 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x19: {
					/* COPzanonymous_21anonymous_11 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x1a: {
					/* COPzanonymous_22anonymous_11 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x1b: {
					/* COPzanonymous_23anonymous_11 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x1c: {
					/* COPzanonymous_24anonymous_11 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x1d: {
					/* COPzanonymous_25anonymous_11 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x1e: {
					/* COPzanonymous_26anonymous_11 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
				case 0x1f: {
					/* COPzanonymous_27anonymous_11 */
					uint32_t cop = ((inst) >> (0x1a)) & (0x3);
					uint32_t cofun = (inst) & (0x1ffffff);
					DO_LDS();
					copfun(cop, cofun, inst);
					return(true);
					break;
				}
			}
			break;
		}
		case 0x20: {
			/* LB */
			uint32_t rs = ((inst) >> (0x15)) & (0x1f);
			uint32_t rt = ((inst) >> (0x10)) & (0x1f);
			uint32_t imm = (inst) & (0xffff);
			DEP(rs);
			RES(rt);
			TGPR(temp_95, rs);
			DO_LDS();
			uint32_t offset = signext(0x10, imm);
			if((rt) != (0x0)) { DEFER_SET(rt, signext(0x8, load_memory(0x8, (temp_95) + (offset), pc))); }
			return(true);
			break;
		}
		case 0x21: {
			/* LH */
			uint32_t rs = ((inst) >> (0x15)) & (0x1f);
			uint32_t rt = ((inst) >> (0x10)) & (0x1f);
			uint32_t imm = (inst) & (0xffff);
			DEP(rs);
			RES(rt);
			TGPR(temp_96, rs);
			DO_LDS();
			uint32_t offset = signext(0x10, imm);
			uint32_t addr = (temp_96) + (offset);
			alignment(addr, 0x10, 0x0, pc);
			if((rt) != (0x0)) { DEFER_SET(rt, signext(0x10, load_memory(0x10, addr, pc))); }
			return(true);
			break;
		}
		case 0x22: {
			/* LWL */
			uint32_t rs = ((inst) >> (0x15)) & (0x1f);
			uint32_t rt = ((inst) >> (0x10)) & (0x1f);
			uint32_t imm = (inst) & (0xffff);
			DEP(rs);
			RES(rt);
			TGPR(temp_97, rs);
			DO_LDS();
			uint32_t simm = signext(0x10, imm);
			uint32_t offset = (temp_97) + (simm);
			uint32_t bottom = (offset) & (0x3);
			uint32_t moffset = (offset) & (0xfffffffc);
			if((bottom) == (0x0)) {
				if((rt) != (0x0)) { DEFER_SET(rt, ((REG(rt)) & (0xffffff)) | ((load_memory(0x8, moffset, pc)) << (0x18))); }
			} else {
				if((bottom) == (0x1)) {
					if((rt) != (0x0)) { DEFER_SET(rt, ((REG(rt)) & (0xffff)) | ((load_memory(0x10, moffset, pc)) << (0x10))); }
				} else {
					if((bottom) == (0x2)) {
						if((rt) != (0x0)) { DEFER_SET(rt, ((REG(rt)) & (0xff)) | ((load_memory(0x18, moffset, pc)) << (0x8))); }
					} else {
						if((rt) != (0x0)) { DEFER_SET(rt, load_memory(0x20, moffset, pc)); }
					}
				}
			}
			return(true);
			break;
		}
		case 0x23: {
			/* LW */
			uint32_t rs = ((inst) >> (0x15)) & (0x1f);
			uint32_t rt = ((inst) >> (0x10)) & (0x1f);
			uint32_t imm = (inst) & (0xffff);
			DEP(rs);
			RES(rt);
			TGPR(temp_98, rs);
			DO_LDS();
			uint32_t offset = signext(0x10, imm);
			uint32_t addr = (temp_98) + (offset);
			alignment(addr, 0x20, 0x0, pc);
			if((rt) != (0x0)) { DEFER_SET(rt, load_memory(0x20, addr, pc)); }
			return(true);
			break;
		}
		case 0x24: {
			/* LBU */
			uint32_t rs = ((inst) >> (0x15)) & (0x1f);
			uint32_t rt = ((inst) >> (0x10)) & (0x1f);
			uint32_t imm = (inst) & (0xffff);
			DEP(rs);
			RES(rt);
			TGPR(temp_99, rs);
			DO_LDS();
			uint32_t offset = signext(0x10, imm);
			if((rt) != (0x0)) { DEFER_SET(rt, load_memory(0x8, (temp_99) + (offset), pc)); }
			return(true);
			break;
		}
		case 0x25: {
			/* LHU */
			uint32_t rs = ((inst) >> (0x15)) & (0x1f);
			uint32_t rt = ((inst) >> (0x10)) & (0x1f);
			uint32_t imm = (inst) & (0xffff);
			DEP(rs);
			RES(rt);
			TGPR(temp_100, rs);
			DO_LDS();
			uint32_t offset = signext(0x10, imm);
			uint32_t addr = (temp_100) + (offset);
			alignment(addr, 0x10, 0x0, pc);
			if((rt) != (0x0)) { DEFER_SET(rt, load_memory(0x10, addr, pc)); }
			return(true);
			break;
		}
		case 0x26: {
			/* LWR */
			uint32_t rs = ((inst) >> (0x15)) & (0x1f);
			uint32_t rt = ((inst) >> (0x10)) & (0x1f);
			uint32_t imm = (inst) & (0xffff);
			DEP(rs);
			RES(rt);
			TGPR(temp_101, rs);
			DO_LDS();
			uint32_t simm = signext(0x10, imm);
			uint32_t offset = (temp_101) + (simm);
			uint32_t bottom = (offset) & (0x3);
			if((bottom) == (0x0)) {
				if((rt) != (0x0)) { DEFER_SET(rt, load_memory(0x20, offset, pc)); }
			} else {
				if((bottom) == (0x1)) {
					if((rt) != (0x0)) { DEFER_SET(rt, ((REG(rt)) & (0xff000000)) | (load_memory(0x18, offset, pc))); }
				} else {
					if((bottom) == (0x2)) {
						if((rt) != (0x0)) { DEFER_SET(rt, ((REG(rt)) & (0xffff0000)) | (load_memory(0x10, offset, pc))); }
					} else {
						if((rt) != (0x0)) { DEFER_SET(rt, ((REG(rt)) & (0xffffff00)) | (load_memory(0x8, offset, pc))); }
					}
				}
			}
			return(true);
			break;
		}
		case 0x28: {
			/* SB */
			uint32_t rs = ((inst) >> (0x15)) & (0x1f);
			uint32_t rt = ((inst) >> (0x10)) & (0x1f);
			uint32_t imm = (inst) & (0xffff);
			DEP(rs);
			DEP(rt);
			TGPR(temp_102, rs);
			TGPR(temp_103, rt);
			DO_LDS();
			uint32_t offset = signext(0x10, imm);
			store_memory(0x8, (temp_102) + (offset), temp_103, pc);
			return(true);
			break;
		}
		case 0x29: {
			/* SH */
			uint32_t rs = ((inst) >> (0x15)) & (0x1f);
			uint32_t rt = ((inst) >> (0x10)) & (0x1f);
			uint32_t imm = (inst) & (0xffff);
			DEP(rs);
			DEP(rt);
			TGPR(temp_104, rs);
			TGPR(temp_105, rt);
			DO_LDS();
			uint32_t offset = signext(0x10, imm);
			uint32_t addr = (temp_104) + (offset);
			alignment(addr, 0x10, 0x1, pc);
			store_memory(0x10, addr, temp_105, pc);
			return(true);
			break;
		}
		case 0x2a: {
			/* SWL */
			uint32_t rs = ((inst) >> (0x15)) & (0x1f);
			uint32_t rt = ((inst) >> (0x10)) & (0x1f);
			uint32_t imm = (inst) & (0xffff);
			DEP(rs);
			DEP(rt);
			TGPR(temp_106, rs);
			TGPR(temp_107, rt);
			DO_LDS();
			uint32_t simm = signext(0x10, imm);
			uint32_t offset = (temp_106) + (simm);
			uint32_t bottom = (offset) & (0x3);
			uint32_t moffset = (offset) & (0xfffffffc);
			if((bottom) == (0x0)) {
				store_memory(0x8, moffset, (temp_107) >> (0x18), pc);
			} else {
				if((bottom) == (0x1)) {
					store_memory(0x10, moffset, (temp_107) >> (0x10), pc);
				} else {
					if((bottom) == (0x2)) {
						store_memory(0x18, moffset, (temp_107) >> (0x8), pc);
					} else {
						store_memory(0x20, moffset, temp_107, pc);
					}
				}
			}
			return(true);
			break;
		}
		case 0x2b: {
			/* SW */
			uint32_t rs = ((inst) >> (0x15)) & (0x1f);
			uint32_t rt = ((inst) >> (0x10)) & (0x1f);
			uint32_t imm = (inst) & (0xffff);
			DEP(rs);
			DEP(rt);
			TGPR(temp_108, rs);
			TGPR(temp_109, rt);
			DO_LDS();
			uint32_t offset = signext(0x10, imm);
			uint32_t addr = (temp_108) + (offset);
			alignment(addr, 0x20, 0x1, pc);
			store_memory(0x20, addr, temp_109, pc);
			return(true);
			break;
		}
		case 0x2e: {
			/* SWR */
			uint32_t rs = ((inst) >> (0x15)) & (0x1f);
			uint32_t rt = ((inst) >> (0x10)) & (0x1f);
			uint32_t imm = (inst) & (0xffff);
			DEP(rs);
			DEP(rt);
			TGPR(temp_110, rs);
			TGPR(temp_111, rt);
			DO_LDS();
			uint32_t simm = signext(0x10, imm);
			uint32_t offset = (temp_110) + (simm);
			uint32_t bottom = (offset) & (0x3);
			if((bottom) == (0x0)) {
				store_memory(0x20, offset, temp_111, pc);
			} else {
				if((bottom) == (0x1)) {
					store_memory(0x18, offset, temp_111, pc);
				} else {
					if((bottom) == (0x2)) {
						store_memory(0x10, offset, temp_111, pc);
					} else {
						store_memory(0x8, offset, temp_111, pc);
					}
				}
			}
			return(true);
			break;
		}
		case 0x32: {
			/* LWC2 */
			uint32_t rs = ((inst) >> (0x15)) & (0x1f);
			uint32_t rt = ((inst) >> (0x10)) & (0x1f);
			uint32_t imm = (inst) & (0xffff);
			DEP(rs);
			TGPR(temp_112, rs);
			DO_LDS();
			uint32_t offset = signext(0x10, imm);
			uint32_t addr = (temp_112) + (offset);
			alignment(addr, 0x20, 0x0, pc);
			write_copreg(0x2, rt, load_memory(0x20, (temp_112) + (offset), pc));
			return(true);
			break;
		}
		case 0x3a: {
			/* SWC2 */
			uint32_t rs = ((inst) >> (0x15)) & (0x1f);
			uint32_t rt = ((inst) >> (0x10)) & (0x1f);
			uint32_t imm = (inst) & (0xffff);
			DEP(rs);
			TGPR(temp_113, rs);
			DO_LDS();
			uint32_t offset = signext(0x10, imm);
			uint32_t addr = (temp_113) + (offset);
			alignment(addr, 0x20, 0x1, pc);
			store_memory(0x20, addr, read_copreg(0x2, rt), pc);
			return(true);
			break;
		}
	}
	return false;
}
